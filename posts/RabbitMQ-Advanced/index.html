<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RabbitMQ高级 | muyoukule</title><meta name="author" content="木又枯了"><meta name="copyright" content="木又枯了"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="RabbitMQ官网：https:&#x2F;&#x2F;www.rabbitmq.com 参考视频：黑马程序员RabbitMQ入门到实战教程，MQ消息中间件，微服务rabbitmq消息队列实战，RabbitMQ面试题一套全覆盖 0. 写在前面在使用 MQ 时我们必须尽可能确保 MQ 消息的可靠性，即：消息应该至少被消费者处理1次 那么问题来了：  我们该如何确保MQ消息的可靠性？ 如果真的发送失败，有没有其它的兜底">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ高级">
<meta property="og:url" content="https://zz.muyoukule.cn/posts/RabbitMQ-Advanced/index.html">
<meta property="og:site_name" content="muyoukule">
<meta property="og:description" content="RabbitMQ官网：https:&#x2F;&#x2F;www.rabbitmq.com 参考视频：黑马程序员RabbitMQ入门到实战教程，MQ消息中间件，微服务rabbitmq消息队列实战，RabbitMQ面试题一套全覆盖 0. 写在前面在使用 MQ 时我们必须尽可能确保 MQ 消息的可靠性，即：消息应该至少被消费者处理1次 那么问题来了：  我们该如何确保MQ消息的可靠性？ 如果真的发送失败，有没有其它的兜底">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zz.muyoukule.cn/img/avatar_muyoukule.png">
<meta property="article:published_time" content="2024-04-01T14:53:00.000Z">
<meta property="article:modified_time" content="2024-04-01T14:53:00.000Z">
<meta property="article:author" content="木又枯了">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zz.muyoukule.cn/img/avatar_muyoukule.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zz.muyoukule.cn/posts/RabbitMQ-Advanced/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"3T0VNEZ7MW","apiKey":"18b3ac6ccf7593531cde30d3383a30f2","indexName":"MyBlog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: 木又枯了","link":"链接: ","source":"来源: muyoukule","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ高级',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 22:53:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar_muyoukule.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about_website/"><i class="fa-fw fas fa-laptop-house"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/about_me/"><i class="fa-fw fas fa-address-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="muyoukule"><span class="site-name">muyoukule</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about_website/"><i class="fa-fw fas fa-laptop-house"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/about_me/"><i class="fa-fw fas fa-address-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ高级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-01T14:53:00.000Z" title="发表于 2024-04-01 22:53:00">2024-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-01T14:53:00.000Z" title="更新于 2024-04-01 22:53:00">2024-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MQ/">MQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9221</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ高级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>RabbitMQ官网：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mN4y1Z7t9/">黑马程序员RabbitMQ入门到实战教程，MQ消息中间件，微服务rabbitmq消息队列实战，RabbitMQ面试题一套全覆盖</a></p>
<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0. 写在前面"></a>0. 写在前面</h1><p>在使用 MQ 时我们必须尽可能确保 MQ 消息的可靠性，即：消息应该至少被消费者处理1次</p>
<p>那么问题来了：</p>
<ul>
<li><strong>我们该如何确保MQ消息的可靠性？</strong></li>
<li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li>
</ul>
<p>这些问题，在下面的学习中都会找到答案。</p>
<h1 id="1-发送者的可靠性"><a href="#1-发送者的可靠性" class="headerlink" title="1. 发送者的可靠性"></a>1. 发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。</p>
<p>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E7%BB%8F%E8%BF%87%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="消息经过的流程"></p>
<p>消息从生产者到消费者的每一步都可能导致消息丢失：</p>
<ul>
<li>发送消息时丢失：<ul>
<li>生产者发送消息时连接 MQ 失败</li>
<li>生产者发送消息到达 MQ后未找到 <code>Exchange</code></li>
<li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code></li>
<li>消息到达 MQ 后，处理消息的进程发生异常</li>
</ul>
</li>
<li>MQ 导致消息丢失：<ul>
<li>消息到达 MQ ，保存到队列后，尚未消费就突然宕机</li>
</ul>
</li>
<li>消费者处理消息时：<ul>
<li>消息接收后尚未处理突然宕机</li>
<li>消息接收后处理过程中抛出异常</li>
</ul>
</li>
</ul>
<p>综上，我们要解决消息丢失问题，保证 MQ 的可靠性，就必须从 3 个方面入手：</p>
<ul>
<li>确保生产者一定把消息发送到 MQ</li>
<li>确保 MQ 不会将消息弄丢</li>
<li>确保消费者一定要处理消息</li>
</ul>
<p>这一章我们先来看如何确保生产者一定能把消息发送到 MQ。</p>
<h2 id="1-1-生产者重试机制"><a href="#1-1-生产者重试机制" class="headerlink" title="1.1 生产者重试机制"></a>1.1 生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断。</p>
<p>为了解决这个问题，SpringAMQP 提供的消息发送时的重试机制。即：当<code>RabbitTemplate </code>与 MQ 连接超时后，多次重试。</p>
<p>1、修改 <code>publisher</code> 模块的 <code>application.yaml</code> 文件，添加下面的内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure>

<p>2、利用命令停掉 RabbitMQ 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></table></figure>
<p>3、然后测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次。消息发送的超时重试机制配置成功了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">03-31 08:54:13:838  INFO 13056 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [192.168.88.132:5672]</span><br><span class="line">03-31 08:54:15:858  INFO 13056 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [192.168.88.132:5672]</span><br><span class="line">03-31 08:54:17:885  INFO 13056 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [192.168.88.132:5672]</span><br></pre></td></tr></table></figure>

<p>PS：这个失败仅仅是连接失败的重试，如果消息发送抛出异常时不会重试😂</p>
<p><strong>注意：</strong></p>
<p>当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p>
<p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p>
<h2 id="1-2-生产者确认机制"><a href="#1-2-生产者确认机制" class="headerlink" title="1.2 生产者确认机制"></a>1.2 生产者确认机制</h2><p>一般情况下，只要生产者与 MQ 之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。</p>
<p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p>
<ul>
<li>MQ 内部处理消息的进程发生了异常</li>
<li>生产者发送消息到达 MQ 后未找到 <code>Exchange</code></li>
<li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code>，因此无法路由</li>
</ul>
<p>针对上述情况，RabbitMQ 提供了生产者消息确认机制，包括 <code>Publisher Confirm</code> 和 <code>Publisher Return</code> 两种。在开启确认机制的情况下，当生产者发送消息给 MQ 后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p>
<p>具体如图所示：<br><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/RabbitMQ%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.png" alt="RabbitMQ生产者消息确认机制"></p>
<p><strong>总结如下：</strong></p>
<ul>
<li>当消息投递到MQ，但是路由失败时，通过 <strong>Publisher Return</strong> 返回异常信息，同时返回 ACK 的确认信息，代表投递成功</li>
<li>临时消息投递到了 MQ，并且入队成功，返回 ACK，告知投递成功</li>
<li>持久消息投递到了 MQ，并且入队完成持久化，返回 ACK ，告知投递成功</li>
<li>其它情况都会返回 NACK，告知投递失败</li>
</ul>
<p>其中 <code>ACK</code> 和 <code>NACK</code> 属于<strong>Publisher Confirm</strong>机制，<code>ACK</code>是投递成功；<code>NACK</code>是投递失败。而<code>return</code>则属于 <strong>Publisher Return</strong> 机制。</p>
<p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p>
<h2 id="1-3-实现生产者确认"><a href="#1-3-实现生产者确认" class="headerlink" title="1.3 实现生产者确认"></a>1.3 实现生产者确认</h2><h3 id="1-3-1-开启生产者确认"><a href="#1-3-1-开启生产者确认" class="headerlink" title="1.3.1 开启生产者确认"></a>1.3.1 开启生产者确认</h3><p>在 publisher 模块的 <code>application.yaml</code> 中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>publisher-confirm-type</code> 有三种模式可选：</p>
<ul>
<li><code>none</code>：关闭 confirm 机制</li>
<li><code>simple</code>：同步阻塞等待 MQ 的回执</li>
<li><code>correlated</code>：MQ 异步回调返回回执</li>
</ul>
<p>一般我们推荐使用 <code>correlated </code>回调机制。</p>
<h3 id="1-3-2-定义ReturnCallback"><a href="#1-3-2-定义ReturnCallback" class="headerlink" title="1.3.2 定义ReturnCallback"></a>1.3.2 定义ReturnCallback</h3><p>每个 <code>RabbitTemplate</code> 只能配置一个 <code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在 publisher 模块定义一个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muyoukule.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-定义ConfirmCallback"><a href="#1-3-3-定义ConfirmCallback" class="headerlink" title="1.3.3 定义ConfirmCallback"></a>1.3.3 定义ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/convertAndSend%E6%96%B9%E6%B3%95.png" alt="convertAndSend方法"></p>
<p>这里的CorrelationData中包含两个核心的东西：</p>
<ul>
<li><code>id</code>：消息的唯一标示，MQ 对不同的消息的回执以此做判断，避免混淆</li>
<li><code>SettableListenableFuture</code>：回执结果的 Future 对象</li>
</ul>
<p>将来 MQ 的回执就会通过这个 <code>Future</code> 来返回，我们可以提前给 <code>CorrelationData</code> 中的 <code>Future</code> 添加回调函数来处理消息回执：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/addCallback%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="addCallback回调函数"></p>
<p>我们新建一个测试，向系统自带的交换机发送消息，并且添加 <code>ConfirmCallback</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="comment">// id 是当前消息的标识，让 RabbitMQ 区分消息，防止产生混乱，不知道该回调给谁</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;消息回调失败&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;收到confirm callback回执&quot;</span>);</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span> (result.isAck()) &#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, 原因 : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-31 09:25:25:604 DEBUG 11344 --- [168.88.132:5672] c.m.publisher.amqp.SpringAmqpTest        : 收到confirm callback回执</span><br><span class="line">03-31 09:25:25:604 DEBUG 11344 --- [168.88.132:5672] c.m.publisher.amqp.SpringAmqpTest        : 发送消息成功，收到 ack!</span><br></pre></td></tr></table></figure>

<p>修改 <code>routingKey</code> 为不存在的 red2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;red2&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">03-31 09:50:32:950  WARN 9664 --- [nectionFactory1] o.s.amqp.rabbit.core.RabbitTemplate      : Returned message but no callback available</span><br><span class="line">03-31 09:50:32:951 DEBUG 9664 --- [168.88.132:5672] c.m.publisher.amqp.SpringAmqpTest        : 收到confirm callback回执</span><br><span class="line">03-31 09:50:32:951 DEBUG 9664 --- [168.88.132:5672] c.m.publisher.amqp.SpringAmqpTest        : 发送消息成功，收到 ack!</span><br></pre></td></tr></table></figure>

<p>修改 <code>exchange</code> 为不存在的 hmall.direct2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct2&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">03-31 09:52:12:691 ERROR 1792 --- [168.88.132:5672] o.s.a.r.c.CachingConnectionFactory       : Shutdown Signal: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;hmall.2&#x27; in vhost &#x27;/hmall&#x27;, class-id=60, method-id=40)</span><br><span class="line">03-31 09:52:12:691 DEBUG 1792 --- [nectionFactory1] c.m.publisher.amqp.SpringAmqpTest        : 收到confirm callback回执</span><br><span class="line">03-31 09:52:12:691 ERROR 1792 --- [nectionFactory1] c.m.publisher.amqp.SpringAmqpTest        : 发送消息失败，收到 nack, 原因 : channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;hmall.2&#x27; in vhost &#x27;/hmall&#x27;, class-id=60, method-id=40)</span><br></pre></td></tr></table></figure>

<p>可以看到，由于传递的 <code>RoutingKey </code>是错误的，路由失败后，触发了 <code>return callback</code>，同时也收到了 ack。</p>
<p>当我们修改为正确的 <code>RoutingKey</code> 以后，就不会触发 <code>return callback</code> 了，只收到ack。</p>
<p>而如果连交换机都是错误的，则只会收到 nack。</p>
<p><strong>注意：</strong></p>
<p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p>
<ul>
<li>路由失败：一般是因为 RoutingKey 错误导致，往往是编程导致</li>
<li>交换机名称错误：同样是编程错误导致</li>
<li>MQ 内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback 处理 nack 就可以了。</li>
</ul>
<h1 id="2-MQ的可靠性"><a href="#2-MQ的可靠性" class="headerlink" title="2. MQ的可靠性"></a>2. MQ的可靠性</h1><p>消息到达 MQ 以后，如果 MQ 不能及时保存，也会导致消息丢失，所以 MQ 的可靠性也非常重要。</p>
<h2 id="2-1-数据持久化"><a href="#2-1-数据持久化" class="headerlink" title="2.1 数据持久化"></a>2.1 数据持久化</h2><p>为了提升性能，默认情况下 MQ 的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p>
<ul>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化</li>
</ul>
<p>我们以控制台界面为例来说明。</p>
<h3 id="2-1-1-交换机持久化"><a href="#2-1-1-交换机持久化" class="headerlink" title="2.1.1 交换机持久化"></a>2.1.1 交换机持久化</h3><p>在控制台的 <code>Exchanges</code> 页面，添加交换机时可以配置交换机的 <code>Durability </code> 参数：</p>
<img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84Durability%E5%8F%82%E6%95%B0.png" alt="交换机的Durability参数" style="zoom: 80%;">

<p>设置为 <code>Durable</code> 就是持久化模式，<code>Transient </code> 就是临时模式。</p>
<h3 id="2-1-2-队列持久化"><a href="#2-1-2-队列持久化" class="headerlink" title="2.1.2 队列持久化"></a>2.1.2 队列持久化</h3><p>在控制台的 Queues 页面，添加队列时，同样可以配置队列的 <code>Durability</code> 参数：</p>
<img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E9%98%9F%E5%88%97%E7%9A%84Durability%E5%8F%82%E6%95%B0.png" alt="队列的Durability参数" style="zoom:67%;">

<p>设置为 <code>Durable</code> 就是持久化模式，<code>Transient </code> 就是临时模式。</p>
<p>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p>
<p><font color="red">PS：Spring 在创建交换机和队列时候默认将他们处理为持久化。</font>😄</p>
<h3 id="2-1-3-消息持久化"><a href="#2-1-3-消息持久化" class="headerlink" title="2.1.3 消息持久化"></a>2.1.3 消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个 <code>properties</code>：</p>
<img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E7%9A%84Delivered%20mode%E5%8F%82%E6%95%B0.png" alt="消息的Delivered mode参数" style="zoom: 80%;">

<p>设置为 <code>2</code> 就是持久化模式，<code>1 </code> 就是临时模式。</p>
<p><strong>说明：</strong></p>
<p>在开启持久化机制以后，如果同时还开启了生产者确认，那么 MQ 会在消息持久化以后才发送 ACK 回执，进一步确保消息的可靠性。</p>
<p>不过出于性能考虑，为了减少 IO 次数，发送到 MQ 的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在 100 毫秒左右，这就会导致 ACK 有一定的延迟，因此建议生产者确认全部采用异步方式。</p>
<h2 id="2-2-LazyQueue"><a href="#2-2-LazyQueue" class="headerlink" title="2.2 LazyQueue"></a>2.2 LazyQueue</h2><p>在默认情况下，RabbitMQ 会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p>
<ul>
<li>消费者宕机或出现网络故障</li>
<li>消息发送量激增，超过了消费者处理速度</li>
<li>消费者处理业务发生阻塞</li>
</ul>
<p>一旦出现消息堆积问题，RabbitMQ 的内存占用就会越来越高，直到触发内存预警上限。此时 RabbitMQ 会将内存消息刷到磁盘上，这个行为成为 <code>PageOut</code>， <code>PageOut </code> 会耗费一段时间，并且会阻塞队列进程。因此在这个过程中 RabbitMQ 不会再处理新的消息，生产者的所有请求都会被阻塞。</p>
<p>为了解决这个问题，从 RabbitMQ 的 3.6.0 版本开始，就增加了 Lazy Queues 的模式，也就是惰性队列。惰性队列的特征如下：</p>
<ul>
<li>接收到消息后<strong>直接存入磁盘而非内存</strong></li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存(也就是懒加载)</li>
<li>支持数百万条的消息存储</li>
</ul>
<p>而在 3.12 版本之后，LazyQueue 已经成为所有队列的默认格式。因此官方推荐升级 MQ 为 3.12 版本或者所有队列都设置为 LazyQueue 模式。</p>
<h3 id="2-2-1-控制台配置Lazy模式"><a href="#2-2-1-控制台配置Lazy模式" class="headerlink" title="2.2.1 控制台配置Lazy模式"></a>2.2.1 控制台配置Lazy模式</h3><p>在添加队列的时候，添加 <code>x-queue-mod=lazy</code> 参数即可设置队列为 Lazy 模式：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E4%B8%BALazy%E6%A8%A1%E5%BC%8F.png" alt="设置队列为Lazy模式"></p>
<h3 id="2-2-2-代码配置Lazy模式"><a href="#2-2-2-代码配置Lazy模式" class="headerlink" title="2.2.2 代码配置Lazy模式"></a>2.2.2 代码配置Lazy模式</h3><p>在利用 SpringAMQP 声明队列的时候，添加 <code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是通过 <code>QueueBuilder</code> 的 <code>lazy()</code> 函数配置Lazy模式，底层源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> QueueBuilder <span class="title function_">lazy</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> withArgument(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以基于注解来声明队列并设置为 Lazy 模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-更新已有队列为Lazy模式"><a href="#2-2-3-更新已有队列为Lazy模式" class="headerlink" title="2.2.3 更新已有队列为Lazy模式"></a>2.2.3 更新已有队列为Lazy模式</h3><p>对于已经存在的队列，也可以配置为 Lazy 模式，但是要通过设置 policy 实现。</p>
<p>可以基于命令行设置 policy：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：RabbitMQ 的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li>
</ul>
<p>当然，也可以在控制台配置 policy，进入在控制台的 <code>Admin</code> 页面，点击 <code>Policies</code>，即可添加配置：</p>
<img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%9B%B4%E6%96%B0%E5%B7%B2%E6%9C%89%E9%98%9F%E5%88%97%E4%B8%BAlazy%E6%A8%A1%E5%BC%8F.png" alt="更新已有队列为lazy模式">

<h1 id="3-消费者的可靠性"><a href="#3-消费者的可靠性" class="headerlink" title="3. 消费者的可靠性"></a>3. 消费者的可靠性</h1><p>当 RabbitMQ 向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p>
<ul>
<li>消息投递的过程中出现了网络故障</li>
<li>消费者接收到消息后突然宕机</li>
<li>消费者接收到消息后，因处理不当导致异常</li>
</ul>
<p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ 必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p>
<p>但问题来了：RabbitMQ 如何得知消费者的处理状态呢？</p>
<p>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p>
<h2 id="2-1-消费者确认机制"><a href="#2-1-消费者确认机制" class="headerlink" title="2.1 消费者确认机制"></a>2.1 消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制(<strong>Consumer Acknowledgement</strong>)。即：当消费者处理消息结束后，应该向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己消息处理状态。回执有三种可选值：</p>
<ul>
<li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li>
<li>nack：消息处理失败，RabbitMQ需要再次投递消息</li>
<li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li>
</ul>
<p>一般 reject 方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过 <code>try catch</code> 机制捕获，消息处理成功时返回 ack，处理失败时返回 nack.</p>
<p>由于消息回执的处理代码比较统一，因此 SpringAMQP 帮我们实现了消息确认。并允许我们通过配置文件设置 ACK 处理方式，有三种模式：</p>
<ul>
<li><code>none</code>：不处理。即消息投递给消费者后立刻ack，消息会立刻从 MQ 删除。非常不安全，不建议使用</li>
<li><code>manual</code>：手动模式。需要自己在业务代码中调用api，发送 <code>ack</code> 或 <code>reject</code>，存在业务入侵，但更灵活</li>
<li><code>auto</code>：自动模式。SpringAMQP 利用 AOP 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ack</code>。 当业务出现异常时，根据异常判断返回不同结果：<ul>
<li>如果是<strong>业务异常</strong>，会自动返回 <code>nack</code>；</li>
<li>如果是<strong>消息处理或校验异常</strong>，自动返回 <code>reject</code>;</li>
</ul>
</li>
</ul>
<p>返回 Reject 的常见异常有：</p>
<p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p>
<ul>
<li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li>
<li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li>
<li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li>
<li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<Foo> but Message<Bar> is received.</Bar></Foo></li>
<li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li>
<li>java.lang.ClassCastException: Added in version 1.6.3.</li>
</ul>
<p>通过下面的配置可以修改 SpringAMQP 的 ACK 处理方式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure>

<p>修改 consumer 服务的 MqRabbitListener 类中的方法，模拟一个消息处理的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者收到了simple.queue的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">&quot;故意的&quot;</span>);	<span class="comment">// 此处断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试可以发现：当消息处理发生异常时，消息依然被 RabbitMQ 删除了。</p>
<p>我们再次把确认机制修改为 auto：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure>

<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为 <code>unacked </code>(未确定状态)：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81unacked.png" alt="消息状态unacked"></p>
<p>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此 Spring 会自动返回 <code>reject</code>，所以消息依然会被删除：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E8%A2%AB%E5%88%A0%E9%99%A4.png" alt="消息被删除"></p>
<p>我们将异常改为 RuntimeException 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者收到了simple.queue的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code> (未确定状态)：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81unacked.png" alt="消息状态unacked"></p>
<p>放行以后，由于抛出的是业务异常，所以 Spring 返回 <code>ack</code>，最终消息恢复至 <code>Ready</code> 状态，并且没有被 RabbitMQ 删除：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%B6%88%E6%81%AF%E6%81%A2%E5%A4%8D%E8%87%B3Ready%E7%8A%B6%E6%80%81.png" alt="消息恢复至Ready状态"></p>
<p>当我们把配置改为 <code>auto</code> 时，消息处理失败后，会回到 RabbitMQ，并重新投递到消费者。</p>
<h2 id="2-2-失败重试机制"><a href="#2-2-失败重试机制" class="headerlink" title="2.2 失败重试机制"></a>2.2 失败重试机制</h2><p>当消费者出现异常后，消息会不断 requeue (重入队)到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次 requeue 到队列，再次投递，直到消息处理成功为止。</p>
<p>极端情况就是消费者一直无法执行成功，那么消息 requeue 就会无限循环，导致 MQ 的消息处理飙升，带来不必要的压力：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/MQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%A3%99%E5%8D%87.png" alt="MQ的消息处理飙升"></p>
<p>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况 Spring 又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的 requeue 到 mq 队列。</p>
<p>修改 <code>consumer</code> 服务的 <code>application.yml</code> 文件，添加内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>重启 <code>consumer</code> 服务，重复之前的测试。可以发现：</p>
<ul>
<li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了 3 次</li>
<li>本地重试 3 次以后，抛出了 <code>AmqpRejectAndDontRequeueException</code> 异常。查看 RabbitMQ 控制台，发现消息被删除了，说明最后 SpringAMQP 返回的是 <code>reject</code></li>
</ul>
<p>结论：</p>
<ul>
<li>开启本地重试时，消息处理过程中抛出异常，不会 requeue 到队列，而是在消费者本地重试</li>
<li>重试达到最大次数后，Spring 会返回 reject，消息会被丢弃</li>
</ul>
<h2 id="2-3-失败处理策略"><a href="#2-3-失败处理策略" class="headerlink" title="2.3 失败处理策略"></a>2.3 失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。<br>因此 Spring 允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由 <code>MessageRecovery</code> 接口来定义的，它有 3 个不同实现：</p>
<ul>
<li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接 <code>reject</code>，丢弃消息。默认就是这种方式 </li>
<li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回 <code>nack</code>，消息重新入队 </li>
<li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li>
</ul>
<p>比较优雅的一种处理方案是 <code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p>
<p>1、在 <code>consumer</code> 服务中定义处理失败消息的交换机和队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义一个 RepublishMessageRecoverer，关联队列和交换机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muyoukule.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行后，去 <code>error.queue</code> 点击 <code>Get Message</code> 查看：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/error.queue%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png" alt="error.queue中的错误信息"></p>
<h2 id="2-4-业务幂等性"><a href="#2-4-业务幂等性" class="headerlink" title="2.4 业务幂等性"></a>2.4 业务幂等性</h2><p>何为幂等性？</p>
<p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p>
<p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p>
<ul>
<li>根据id删除数据</li>
<li>查询数据</li>
<li>新增数据</li>
</ul>
<p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p>
<ul>
<li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li>
<li>退款业务。重复退款对商家而言会有经济损失。</li>
</ul>
<p>所以，我们要尽可能避免业务被重复执行。</p>
<p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p>
<ul>
<li>页面卡顿时频繁刷新导致表单重复提交</li>
<li>服务间调用的重试</li>
<li>MQ消息的重复投递</li>
</ul>
<p>我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。</p>
<p>举例：</p>
<ul>
<li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li>
<li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li>
<li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li>
<li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li>
</ul>
<p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p>
<ul>
<li>唯一消息ID</li>
<li>业务状态判断</li>
</ul>
<h3 id="2-4-1-唯一消息ID"><a href="#2-4-1-唯一消息ID" class="headerlink" title="2.4.1 唯一消息ID"></a>2.4.1 唯一消息ID</h3><p>这个思路非常简单：</p>
<ol>
<li>每一条消息都生成一个唯一的id，与消息一起投递给消费者</li>
<li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li>
<li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理</li>
</ol>
<p>我们该如何给消息添加唯一ID呢？</p>
<p>其实很简单，SpringAMQP的 MessageConverter 自带了 MessageID 的功能，我们只要开启这个功能即可。</p>
<p>以 Jackson 的消息转换器为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-业务判断"><a href="#2-4-2-业务判断" class="headerlink" title="2.4.2 业务判断"></a>2.4.2 业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p>
<p>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p>
<p>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p>
<p>以支付修改订单的业务为例，我们需要修改 <code>OrderServiceImpl</code> 中的 <code>markOrderPaySuccess</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p>
<p>我们可以合并上述操作为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看，上述代码等同于这样的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们在 where 条件中除了判断 id 以外，还加上了 status 必须为1的条件。如果条件不符(说明订单已支付)，则 SQL 匹配不到数据，根本不会执行。</p>
<h2 id="2-5-兜底方案"><a href="#2-5-兜底方案" class="headerlink" title="2.5 兜底方案"></a>2.5 兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息 100% 的可靠。万一真的 MQ 通知失败该怎么办呢？<br>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p>
<p>其实思想很简单：既然 MQ 通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的 MQ 通知失败，我们依然能通过主动查询来保证订单状态的一致。</p>
<p>流程如下：</p>
<img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="服务流程" style="zoom: 50%;">

<p>图中黄色线圈起来的部分就是 MQ 通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p>
<p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确(比如查询的时候用户正在支付中)，可能查询到的支付状态也不正确。</p>
<p>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p>
<p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。定时任务具体的实现这里就不再赘述了😏</p>
<p>至此，消息可靠性的问题已经解决了。</p>
<p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p>
<ul>
<li>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步。</li>
<li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li>
<li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便 MQ 通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li>
</ul>
<h1 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4. 延迟消息"></a>4. 延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p>
<p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p>
<p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p>
<p>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p>
<p>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p>
<p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用 MQ 的延迟消息了。</p>
<p>在 RabbitMQ 中实现延迟消息也有两种方案：</p>
<ul>
<li>死信交换机+TTL</li>
<li>延迟消息插件</li>
</ul>
<p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p>
<h2 id="4-1-死信交换机和延迟消息"><a href="#4-1-死信交换机和延迟消息" class="headerlink" title="4.1 死信交换机和延迟消息"></a>4.1 死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p>
<h3 id="4-1-1-死信交换机"><a href="#4-1-1-死信交换机" class="headerlink" title="4.1.1 死信交换机"></a>4.1.1 死信交换机</h3><p>什么是死信？</p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信(dead letter)：</p>
<ul>
<li>消费者使用 <code>basic.reject</code> 或  <code>basic.nack </code>声明消费失败，并且消息的 <code>requeue</code> 参数设置为 false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息满了，无法投递</li>
</ul>
<p>如果一个队列中的消息已经成为死信，并且这个队列通过 <code>dead-letter-exchange</code> 属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为 <strong>死信交换机</strong>(Dead Letter Exchange)。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p>
<p>死信交换机有什么作用呢？</p>
<ul>
<li>收集那些因处理失败而被拒绝的消息</li>
<li>收集那些因队列满了而被拒绝的消息</li>
<li>收集因TTL(有效期)到期的消息</li>
</ul>
<h3 id="4-1-2-延迟消息"><a href="#4-1-2-延迟消息" class="headerlink" title="4.1.2 延迟消息"></a>4.1.2 延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的 <code>RepublishMessageRecoverer</code> 作用类似。</p>
<p>而最后一种场景，大家设想一下这样的场景：</p>
<p>如图，有一组绑定的交换机 <code>ttl.fanout</code> 和队列 <code>ttl.queue</code>。但是 <code>ttl.queue</code> 没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列 <code>direct.queue1 </code> 则与死信交换机绑定，<code>RoutingKey</code> 是 <code>blue</code>：<br><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E5%9C%BA%E6%99%AF.png" alt="场景"></p>
<p>假如我们现在发送一条消息到 <code>ttl.fanout</code>，<code>RoutingKey</code> 为 <code>blue</code>，并设置消息的<strong>有效期</strong>为 5000 毫秒：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E5%8F%91%E9%80%81%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E5%88%B0ttl.fanout.png" alt="发送一条消息到ttl.fanout"></p>
<p><strong>注意</strong>：尽管这里的 <code>ttl.fanout</code> 不需要 <code>RoutingKey</code>，但是当消息变为死信并投递到死信交换机时，会沿用之前的 <code>RoutingKey</code>，这样 <code>hmall.direct </code>才能正确路由消息。</p>
<p>消息肯定会被投递到 <code>ttl.queue</code> 之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：<br><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/5%E7%A7%92%E5%90%8E%E6%B6%88%E6%81%AF%E6%88%90%E4%B8%BA%E6%AD%BB%E4%BF%A1.png" alt="5秒后消息成为死信"><br>死信被再次投递到死信交换机 <code>hmall.direct</code>，并沿用之前的 <code>RoutingKey</code>，也就是 <code>blue</code>：<br><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/%E6%AD%BB%E4%BF%A1%E8%A2%AB%E5%86%8D%E6%AC%A1%E6%8A%95%E9%80%92%E5%88%B0%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BAhmall.direct.png" alt="死信被再次投递到死信交换机hmall.direct"></p>
<p>由于 <code>direct.queue1</code> 与 <code>hmall.direct</code> 绑定的 <code>key</code> 是 <code>blue</code>，因此最终消息被成功路由到 <code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code> 绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/5%E7%A7%92%E9%92%9F%E4%BB%A5%E5%90%8E%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.png" alt="5秒钟以后消费消息"><br>也就是说，publisher 发送了一条消息，但最终 consumer 在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>RabbitMQ 的消息过期是基于追溯方式来实现的，也就是说当一个消息的 TTL 到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p>
<p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的 TTL 时间不一定准确。</p>
<h2 id="4-2-DelayExchange插件"><a href="#4-2-DelayExchange插件" class="headerlink" title="4.2.DelayExchange插件"></a>4.2.DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。</p>
<p>官方文档说明：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1.下载"></a>4.2.1.下载</h3><p>插件下载地址：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p>由于我们安装的MQ是 <code>3.8</code> 版本，因此这里下载 <code>3.8.17</code> 版本：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/DelayExchange%E6%8F%92%E4%BB%B6v3.8.17.png" alt="DelayExchange插件v3.8.17"></p>
<h3 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2.安装"></a>4.2.2.安装</h3><p>因为我们是基于 Docker 安装，所以需要先查看 RabbitMQ 的插件目录对应的数据卷。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2024-06-19T09:22:59+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mq-plugins/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;mq-plugins&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插件目录被挂载到了 <code>/var/lib/docker/volumes/mq-plugins/_data</code> 这个目录，我们上传插件到该目录下。</p>
<p>接下来执行命令，安装插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://muyoukule-blog-pics.oss-cn-chengdu.aliyuncs.com/MQIMG/RabbitMQ/DelayExchange%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png" alt="DelayExchange插件安装结果"></p>
<h3 id="4-2-3-声明延迟交换机"><a href="#4-2-3-声明延迟交换机" class="headerlink" title="4.2.3.声明延迟交换机"></a>4.2.3.声明延迟交换机</h3><p>基于注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 <code>@Bean  </code> 的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muyoukule.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-发送延迟消息"><a href="#4-2-4-发送延迟消息" class="headerlink" title="4.2.4.发送延迟消息"></a>4.2.4.发送延迟消息</h3><p>发送消息时，必须通过 <code>x-delay</code> 属性设定延迟时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>延迟消息插件内部会维护一个本地数据库表，同时使用 Elang Timers 功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的 CPU 开销，同时延迟消息的时间会存在误差。</p>
<p>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zz.muyoukule.cn">木又枯了</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zz.muyoukule.cn/posts/RabbitMQ-Advanced/">https://zz.muyoukule.cn/posts/RabbitMQ-Advanced/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zz.muyoukule.cn" target="_blank">muyoukule</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Mybatis-Plus/" title="国产&quot;猛男&quot;——MyBatis-Plus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">国产&quot;猛男&quot;——MyBatis-Plus</div></div></a></div><div class="next-post pull-right"><a href="/posts/Java-Create-Object-Method/" title="没有对象怎么办？——Java中创建对象的方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">没有对象怎么办？——Java中创建对象的方法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/RabbitMQ-Basics/" title="RabbitMQ基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">RabbitMQ基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">0. 写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%91%E9%80%81%E8%80%85%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">1. 发送者的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">1.1 生产者重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2 生产者确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-text">1.3 实现生产者确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%BC%80%E5%90%AF%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-text">1.3.1 开启生产者确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%AE%9A%E4%B9%89ReturnCallback"><span class="toc-text">1.3.2 定义ReturnCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%AE%9A%E4%B9%89ConfirmCallback"><span class="toc-text">1.3.3 定义ConfirmCallback</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MQ%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">2. MQ的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1 数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.1 交换机持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.2 队列持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.3 消息持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-LazyQueue"><span class="toc-text">2.2 LazyQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%85%8D%E7%BD%AELazy%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.1 控制台配置Lazy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AELazy%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.2 代码配置Lazy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%9B%B4%E6%96%B0%E5%B7%B2%E6%9C%89%E9%98%9F%E5%88%97%E4%B8%BALazy%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.3 更新已有队列为Lazy模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">3. 消费者的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1 消费者确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">2.2 失败重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">2.3 失败处理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">2.4 业务幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%94%AF%E4%B8%80%E6%B6%88%E6%81%AFID"><span class="toc-text">2.4.1 唯一消息ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E4%B8%9A%E5%8A%A1%E5%88%A4%E6%96%AD"><span class="toc-text">2.4.2 业务判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%9C%E5%BA%95%E6%96%B9%E6%A1%88"><span class="toc-text">2.5 兜底方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4. 延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.1 死信交换机和延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">4.1.1 死信交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.1.2 延迟消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-DelayExchange%E6%8F%92%E4%BB%B6"><span class="toc-text">4.2.DelayExchange插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E4%B8%8B%E8%BD%BD"><span class="toc-text">4.2.1.下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%AE%89%E8%A3%85"><span class="toc-text">4.2.2.安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%A3%B0%E6%98%8E%E5%BB%B6%E8%BF%9F%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">4.2.3.声明延迟交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%8F%91%E9%80%81%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.2.4.发送延迟消息</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"><span><b>&copy;2024</b></span><span><b>&nbsp;&nbsp;By 木又枯了</b></span></div><div class="footer_custom_text">【The future of the past is now】</div><div id="workboard"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button class="darkmode" type="button" title="切换模式" onclick="darkmode()"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script async src="/js/muyoukule.js"></script><script defer src="/live2d-widget/autoload.js"></script><script defer src="/js/runtime.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="mu,you,ku,le" data-fontsize="18px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '300ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '50');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>